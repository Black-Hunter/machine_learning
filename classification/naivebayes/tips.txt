(1) When copy constructor or assignment operator= is called?
Consider the following code snippet:
#Test.h
class Test {
private:
    int integer;

public:
    Test(int i): integer(i) {
        std::cout<<"Test constructor is called!"<<std::endl;
    }

    Test(const Test& test) {
        std::cout<<"Test copy constructor is called!"<<std::endl;

        integer = test.integer;
    }

    Test& operator=(const Test& test) {
        std::cout<<"Test assignment operator= is called!"<<std::endl;

        integer = test.integer;
    }

    ~Test() {
    }
};

#main.cpp
#include "test.h"

int main(int argc, char** argv) {
    Test test1(55);
    std::cout<<"..."<<std::endl;
    Test test2(test1);
    std::cout<<"..."<<std::endl;
    Test test3 = test1;
    std::cout<<"..."<<std::endl;
    test3 = test2;
    std::cout<<"..."<<std::endl;

    return 0;
}

Output:
Test constructor is called!
...
Test copy constructor is called!
...
Test copy constructor is called!
...
Test assignment operator= is called!
...

As can be seen from the output above, constructor is called to initialize an object when it is defined with non-self-object argument. 
And copy constructor is called to initialize an object when it is defined with another object with the same type. 
You must note that statement "Test test3 = test1;" in the above code snippet calls copy constructor instead of assignment operator= to initialize
object test3, since test3 is initialized for the first time. Assignment operator= is called only when an existing object is assigned with another
object with the same type, as the statement "test3 = test2;" satement in the above statement.

(2) How objects are initialized when they are stored in a STL container?
When an object in a STL container is initialized, the object's no-argument constructor is called to constructor a temporary object, then calls the
object's copy constructor to initialize the object. 

