(1) When using std::vector, we can't access to the elements in it with out of bound index.
For example:
	std::vector<std::string> vec;
	vec[0] = "";
The code snippet above will cause segment fault, since 'vec' is initialized as an empty std::vector, so adding an element by index '0' is invalid.
But adding an element by calling 'push_back' as follows is OK, since it will cause memory reallocate to 'vec' if the space is not enough.
	vec.push_back("");

(2) When you provide access to your-defined class via indexing, it is a good habit to provide both const and non-const overload of 'operator[]'.
const T& operator[](const int index)const;
T& operator[](const int index);

(3) When you use a your-defined class as the key of a std::set/sd::map, you should overload 'operator<' and the overload should work.
std::set/std::map uses std::less<key_type> to compare keys when inserting elements into the red-black tree, the elements whose keys do not hold the
< relationshop are treated as the same ones.

(4) How to declare a template function as a friend of a template class, and constrains template parameter the friend template function to the 
template class' template parameter?
Let's take overload of 'operator<<' of template class 'SampleSet' as an example:
Firstly, define a generic overload of 'operator<<':
template<typename U>
std::ostream& operator<<(std::ostream& os, const SampleSet<U>& sampleSet) {
	...
}

Secondly, declare overload of 'operator<<' as a friend function of template class 'SampleSet' and constrains template parameter:
template<typename T>
class SampleSet{
...

public:
	...
	friend std::ostream& operator<< <T>(std::ostream& os, const SampleSet<T>& sampleSet);
	...
};

